<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>clQMC: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clQMC
   </div>
   <div id="projectbrief">An OpenCL library for quasi-Monte Carlo methods</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We introduce clQMC, an OpenCL library for quasi-Monte Carlo methods. It provides facilities for using quasi-Monte Carlo methods to integrate functions over the unit hypercube in arbitrary dimension. Quasi-Monte Carlo methods can radically improve the accuracy of the estimator as compared to simple Monte Carlo. The main idea is to replace the independent uniform random numbers used in a simulation by quasi-Monte Carlo points.</p>
<p>With clQMC, quasi-Monte Carlo point sets are created on the host, and streams are attached to them to enumerate the points on the host or on the device. These streams act as sources of numbers in \((0,1)\) and can replace the streams from the <a href="https://github.com/clMathLibraries/clRNG">clRNG library</a> in code that uses them (we show how to do this in <a class="el" href="index.html#examples">Usage Examples: From Monte Carlo to Randomized Quasi-Monte Carlo</a>). The clProbDist library can also be used on top of clQMC for generating nonuniform variates. The design is closely inspired from that of the <a href="http://simul.iro.umontreal.ca/ssj/">SSJ library</a> <a class="el" href="citelist.html#CITEREF_iLEC08j">[5]</a> .</p>
<dl class="section warning"><dt>Warning</dt><dd>This is only an API proposal. The actual library is not fully implemented. Only rank-1 lattice rules are implemented for illustration of the ideas.</dd></dl>
<h3>What to read next?</h3>
<ul>
<li><a class="el" href="index.html#qmc">About Quasi-Monte Carlo Methods</a></li>
<li><a class="el" href="index.html#examples">Usage Examples: From Monte Carlo to Randomized Quasi-Monte Carlo</a></li>
<li><a class="el" href="clQMC__template_8h.html">API supported by each point set </a> presented in a generic fashion</li>
<li><a class="el" href="clQMC_8h.html">API not related to specific point sets </a></li>
<li><a class="el" href="index.html#configuration">Configuration</a></li>
<li><a class="el" href="index.html#mem_types">Device memory types</a> (advanced usage)</li>
</ul>
<h1><a class="anchor" id="qmc"></a>
About Quasi-Monte Carlo Methods</h1>
<h2><a class="anchor" id="qmc_mc"></a>
Monte Carlo</h2>
<p><b>Monte Carlo</b> integration estimates the expectation \(\mu = \mathbb E[X]\) of a random variate \(X\) by the average </p><p class="formulaDsp">
\[ \hat\mu_{\mathrm{mc}} = \frac1n \sum_{i=0}^{n-1} X_i \]
</p>
<p> of \(n\) independent realizations \(X_0,\dots,X_{n-1}\) of \(X\). Each \(X_i\) is usually generated by simulation, using say \(s\) independent (pseudo)random numbers \(U_{i,1},\dots,U_{i,s}\) uniformly distributed over \((0,1)\) for its source of randomness, so one can write \(X_i = f(\boldsymbol U_i)\), where \(\boldsymbol U_i = (U_{i,1},\dots,U_{i,s})\) for \(i=0,\dots,n-1\), for some function \(f : [0,1)^s \to \mathbb R\). For standard Monte Carlo, the points \(\boldsymbol U_i\) are independent and uniformly distributed in the \(s\)-dimensional hypercube \((0,1)^s\).</p>
<p>The variance of the Monte Carlo estimator \(\hat\mu_{\mathrm{mc}}\) decreases as \(n^{-1}\). This slow convergence rate is due to the uneven coverage of the integration domain \((0,1)^s\) by the independent random points \(\boldsymbol U_0, \dots, \boldsymbol U_{n-1}\).</p>
<h2><a class="anchor" id="qmc_qmc"></a>
Quasi-Monte Carlo</h2>
<p><b>Quasi-Monte Carlo</b> methods (see <a class="el" href="citelist.html#CITEREF_rNIE92a">[8]</a>, <a class="el" href="citelist.html#CITEREF_vSLO94a">[10]</a>, <a class="el" href="citelist.html#CITEREF_vLEC00b">[2]</a>, <a class="el" href="citelist.html#CITEREF_vLEC09f">[6]</a>, <a class="el" href="citelist.html#CITEREF_sLEM09a">[7]</a>, <a class="el" href="citelist.html#CITEREF_rDIC10a">[1]</a>, <a class="el" href="citelist.html#CITEREF_rNUY14a">[9]</a>) can provide faster convergence. They replace the independent random points \(\boldsymbol U_0, \dots, \boldsymbol U_{n-1}\) with deterministic, structured points \(\boldsymbol u_0, \dots, \boldsymbol u_{n-1}\) that cover the integration domain more evenly. Popular quasi-Monte Carlo methods include lattice rules and digital nets (which include Sobol sequences and polynomial lattice rules, for example). The quasi-Monte Carlo estimator is deterministic: </p><p class="formulaDsp">
\[ \hat\mu_{\mathrm{qmc}} = \frac1n \sum_{i=0}^{n-1} f(\boldsymbol u_i). \]
</p>
<h3><a class="anchor" id="qmc_qmc_latrules"></a>
Rank-1 Lattice Rules</h3>
<p>For <b>rank-1 lattice rules</b>, the points are defined as </p><p class="formulaDsp">
\[ \boldsymbol u_i = \frac{i \boldsymbol a \bmod n}{n} \]
</p>
<p> for \(i=0,\dots,n-1\), where the quality of the point set depends on the choice of the generating vector \(\boldsymbol a \in \{1,\dots,n-1\}^s\). The modulo operation in the above formula is applied coordinate by coordinate. External software may be needed in order to find a proper generating vector \(\boldsymbol a\) for any given integration problem (for a given dimension, number of points, etc.). We recommend <a href="https://github.com/mungerd/latbuilder">Lattice Builder</a> <a class="el" href="citelist.html#CITEREF_vLEC15a">[4]</a> . An important advantage of lattice rules is that enumerating their points requires a trivial computational effort, which can be very helpful for use on a GPU.</p>
<h2><a class="anchor" id="qmc_rqmc"></a>
Randomized Quasi-Monte Carlo</h2>
<p><b>Randomized Quasi-Monte Carlo</b> produces an unbiased stochastic estimator </p><p class="formulaDsp">
\[ \hat\mu_{\mathrm{rqmc}} = \frac1n \sum_{i=0}^{n-1} f(\boldsymbol U_i) \]
</p>
<p> by randomizing the quasi-Monte Carlo points \(\boldsymbol u_i \mapsto \boldsymbol U_i\) in a way that preserves their mutual structure, and such that each randomized point \(\boldsymbol U_i\) is uniformly distributed in \((0,1)^s\), when taken separately.</p>
<p>Usually, one generates several replications of \(\hat\mu_{\mathrm{rqmc}}\) to estimate its mean and variance, and thus obtain both a better estimation of \(\mu\) together with an indication of the accuracy of this estimation. It is generally more productive to increase the number of points than the number of randomizations to obtain a better estimation.</p>
<h3><a class="anchor" id="qmc_rqmc_latrules"></a>
Randomly-Shifted Rank-1 Lattice Rules</h3>
<p>For rank-1 lattice rules, the randomization is generally a periodic random shift, i.e., a random vector \(\boldsymbol U\) uniformly distributed in \((0,1)^s\) is added (modulo 1) to each point: </p><p class="formulaDsp">
\[ \boldsymbol U_i = (\boldsymbol u_i + \boldsymbol U) \bmod 1, \]
</p>
<p> for \(i=0,\dots,n-1\). The result is called a <b>randomly-shifted rank-1 lattice rule</b>. See <a class="el" href="citelist.html#CITEREF_vLEC00b">[2]</a> and <a class="el" href="citelist.html#CITEREF_vLEC12a">[3]</a> .</p>
<h1><a class="anchor" id="examples"></a>
Usage Examples: From Monte Carlo to Randomized Quasi-Monte Carlo</h1>
<p>We show here how existing Monte Carlo code that uses <a href="https://github.com/clMathLibraries/clRNG">clRNG</a> streams can be adapted to quasi-Monte Carlo methods by using clQMC streams instead. We further show how to combine clQMC and clRNG streams to apply randomized quasi-Monte Carlo.</p>
<h2><a class="anchor" id="examples_model"></a>
Example Model</h2>
<p>Suppose we want to integrate </p><p class="formulaDsp">
\[ f(u_1,\dots,u_s) = \prod_{j=1}^s \frac{u_j^2}{3}, \]
</p>
<p> in dimension \(s=30\).</p>
<p>We want our implementation of \(f(u_1,\dots,u_s)\) to take as input a stream from either clRNG (for Monte Carlo) or clQMC (for quasi-Monte Carlo), and to obtain the successive coordinates \(u_1,\dots,u_s\) as successive outputs from the stream. However, the type of the stream and the function that generates outputs from the stream have different names in clRNG and clQMC, so we refer to them through the preprocessor symbols <code>StreamType</code> and <code>nextCoordinate()</code>, respectively. This allows us to define them later, in accordance with the simulation method we want to use.</p>
<p>The following function evaluates \(f(u_1,\dots,u_s)\) by generating the coordinates of the point \((u_1,\dots,u_s)\) through successive calls to <code>nextCoordinate()</code> on the input stream <code>stream</code>, as specified above: </p><div class="fragment"><div class="line"><span class="preprocessor">#define DIMENSION 30</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> simulateOneRun(StreamType* stream)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> ret = 1.0;</div>
<div class="line">  <span class="keywordflow">for</span> (uint j = 0; j &lt; DIMENSION; j++) {</div>
<div class="line">    <span class="keywordtype">double</span> uj = nextCoordinate(stream);</div>
<div class="line">    ret *= 3 * uj * uj;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The complete implementation is given in <a class="el" href="DocsTutorial_2common_8clh-example.html">DocsTutorial/common.clh</a>. Henceforth, we refer to the dimension \(s=30\) through the constant <code>DIMENSION</code>.</p>
<h2><a class="anchor" id="examples_mc"></a>
Example 1: Monte Carlo</h2>
<p>To perform Monte Carlo integration, we use the MRG31k3p generator from <a href="https://github.com/clMathLibraries/clRNG">clRNG</a>. Every work item evaluates the integrand \(f\) at <code>nw</code> distinct points, each provided by a distinct substream (see the documentation of <a href="https://github.com/clMathLibraries/clRNG">clRNG</a>).</p>
<p>We define <code>StreamType</code> and <code>nextCoordinate</code>, from the definition of <code>simulateOneRun()</code> given in <a class="el" href="index.html#examples_model">Example Model</a>, to use MRG31k3p streams: </p><div class="fragment"><div class="line"><span class="preprocessor">#define StreamType     clrngMrg31k3pStream</span></div>
<div class="line"><span class="preprocessor">#define nextCoordinate clrngMrg31k3pRandomU01</span></div>
</div><!-- fragment --><p> The OpenCL kernel stores at a unique location in the output array <code>out</code> the average of <code>nw</code> values of \(f\), obtained by invoking <code>simulateOneRun()</code> with <code>nw</code> different substreams: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> sum = 0.0;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (uint i = 0; i &lt; nw; i++) {</div>
<div class="line">  sum += simulateOneRun(&amp;stream);</div>
<div class="line">  clrngMrg31k3pForwardToNextSubstreams(1, &amp;stream);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">out[get_global_id(0)] = sum / nw;</div>
</div><!-- fragment --><p> The above code assumes that the variable <code>stream</code> already contains the stream object assigned to the current work item. The host is responsible for averaging the values stored in <code>out</code> by the work items and obtain \(\hat\mu_{\mathrm{mc}}\).</p>
<p>Details about the clRNG device API (used in the above kernel) and about writing host code to send stream objects to the device are explained in the clRNG documentation.</p>
<p>The complete code for this example is given in <a class="el" href="DocsTutorial_2example1_8c-example.html">DocsTutorial/example1.c</a> and <a class="el" href="DocsTutorial_2example1_kernel_8cl-example.html">DocsTutorial/example1_kernel.cl</a>.</p>
<h2><a class="anchor" id="examples_qmc"></a>
Example 2: Quasi-Monte Carlo</h2>
<p>Here, we replace the Monte Carlo points from <a class="el" href="index.html#examples_mc">Example 1: Monte Carlo</a> with quasi-Monte Carlo points by using rank-1 lattice rule streams from clQMC instead of MRG31k3p streams from clRNG. Every work item evaluates the integrand \(f\) at only <code>nw</code> of the lattice points.</p>
<p>We redefine <code>StreamType</code> and <code>nextCoordinate</code> to use lattice rule streams: </p><div class="fragment"><div class="line"><span class="preprocessor">#define StreamType     clqmcLatticeRuleStream</span></div>
<div class="line"><span class="preprocessor">#define nextCoordinate clqmcLatticeRuleNextCoordinate</span></div>
</div><!-- fragment --><p> In the device code, we include the clQMC header for lattice rules: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="latticerule_8clh.html">clQMC/latticerule.clh</a>&gt;</span></div>
</div><!-- fragment --><p> The kernel receives the lattice point set object as one of its arguments, declared as: </p><div class="fragment"><div class="line">__global <span class="keyword">const</span> clqmcLatticeRule* pointset</div>
</div><!-- fragment --><p> This lattice point set object is stored in global memory and is shared across all work items. Each work item, however, attaches its own <em>stream object</em> to the point set by invoking <a class="el" href="latticerule_8h.html#a8811331e452bbda86dc98ebff7b91096" title="Attach a new stream to a point set object in already allocated memory [device]. ">clqmcLatticeRuleCreateOverStream()</a>: </p><div class="fragment"><div class="line">clqmcLatticeRuleStream stream; <span class="comment">// in private memory</span></div>
<div class="line"><a class="code" href="latticerule_8h.html#a8811331e452bbda86dc98ebff7b91096">clqmcLatticeRuleCreateOverStream</a>(&amp;stream, pointset,</div>
<div class="line">  get_global_size(0), get_global_id(0),</div>
<div class="line">  (<span class="keywordtype">void</span>*)0);</div>
</div><!-- fragment --><p> The third argument to <a class="el" href="latticerule_8h.html#a8811331e452bbda86dc98ebff7b91096" title="Attach a new stream to a point set object in already allocated memory [device]. ">clqmcLatticeRuleCreateOverStream()</a> defines a partition of the lattice point set into <code>get_global_size(0)</code> even subsets, and the fourth argument selects the subset of index <code>get_global_id(0)</code> as the source of this work item's stream. The internal structure of the partitioning may depend on the type of point set used. We slightly modify the main loop to forward the stream to the next point instead of to the next substream: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (uint i = 0; i &lt; nw; i++) {</div>
<div class="line">  sum += simulateOneRun(&amp;stream);</div>
<div class="line">  <a class="code" href="latticerule_8h.html#a2f3b06ce553061c32a8d8dc417696d49">clqmcLatticeRuleForwardToNextPoint</a>(&amp;stream);</div>
<div class="line">}</div>
</div><!-- fragment --><p>On the host, we include the clQMC header file for lattice: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="latticerule_8h.html">clQMC/latticerule.h</a>&gt;</span></div>
</div><!-- fragment --><p> A lattice point set that contains <code>n</code> points is created by invoking <a class="el" href="latticerule_8h.html#a4f73662af3e522dfabf60419fa59368d" title="Create a new rank-1 lattice rule. ">clqmcLatticeRuleCreate()</a> with a proper generating vector <code>gen_vec</code> (selected beforehand): </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> pointset_size;</div>
<div class="line">cl_int gen_vec[] = { ... };</div>
<div class="line">clqmcLatticeRule* pointset = <a class="code" href="latticerule_8h.html#a4f73662af3e522dfabf60419fa59368d">clqmcLatticeRuleCreate</a>(n, DIMENSION, gen_vec, &amp;pointset_size, &amp;err);</div>
</div><!-- fragment --><p> The resulting object <code>pointset</code>, of size <code>pointset_size</code> in bytes, can be copied to the device using standard OpenCL techniques (not shown here).</p>
<p>The complete code for this example is given in <a class="el" href="DocsTutorial_2example2_8c-example.html">DocsTutorial/example2.c</a> and <a class="el" href="DocsTutorial_2example2_kernel_8cl-example.html">DocsTutorial/example2_kernel.cl</a>.</p>
<h2><a class="anchor" id="examples_rqmc"></a>
Example 3: Randomized Quasi-Monte Carlo</h2>
<p>To use randomized quasi-Monte Carlo, we can add a periodic random shift \(\boldsymbol U\), as explained in <a class="el" href="index.html#qmc_rqmc">Randomized Quasi-Monte Carlo</a>, to a lattice rule. As in <a class="el" href="index.html#examples_qmc">Example 2: Quasi-Monte Carlo</a>, each work item is assigned a specific subset of the whole point set. But here, a work item is also responsible for generating all of the <code>replications</code> realizations of \(f(\boldsymbol U_i)\) for each point \(\boldsymbol U_i\) it was assigned. Each realization requires a distinct random \(\boldsymbol U\), and it is the same for all points, so it is the same for all work items. We thus store the random shifts in advance on the host and copy them into the device's global memory in an array named <code>shifts</code>, composed of <code>replications</code> tuples of <code>DIMENSION</code> values (one for each point and each coordinate).</p>
<p>In the kernel code, for each replication of index <code>k</code>, we create a new lattice rule stream using the <code>k</code>-th random shift vector: </p><div class="fragment"><div class="line">clqmcLatticeRuleStream stream;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (uint k = 0; k &lt; replications; k++) {</div>
<div class="line"></div>
<div class="line">  <a class="code" href="latticerule_8h.html#a8811331e452bbda86dc98ebff7b91096">clqmcLatticeRuleCreateOverStream</a>(&amp;stream, pointset,</div>
<div class="line">    get_global_size(0), get_global_id(0),</div>
<div class="line">    &amp;shifts[k * DIMENSION]);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// ... (compute the value of `sum&#39; here; this is unchanged)</span></div>
<div class="line"></div>
<div class="line">  out[k * get_global_size(0) + get_global_id(0)] = sum / nw;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The average associated with each random shift is stored at a distinct location in the output array <code>out</code>, divided into <code>replications</code> blocks of size <code>get_global_size(0)</code> (one for each replication).</p>
<p>In very high dimension, it might be preferable not to store all the random shifts in advance but to pass random streams to the kernel and let the work items generate the single shift they need at the moment they need it.</p>
<p>The complete code for this example is given in <a class="el" href="DocsTutorial_2example3_8c-example.html">DocsTutorial/example3.c</a> and <a class="el" href="DocsTutorial_2example3_kernel_8cl-example.html">DocsTutorial/example3_kernel.cl</a>.</p>
<h2><a class="anchor" id="examples_rqmc_adv"></a>
Example 4: Advanced Randomized Quasi-Monte Carlo</h2>
<p>We refine <a class="el" href="index.html#examples_rqmc">Example 3: Randomized Quasi-Monte Carlo</a> to allow for the work on different replications for the same points to be shared across multiple work items. We partition the replications into <code>r / rw</code> blocks of size <code>rw</code>, as the whole point set is partitioned into <code>N = n / nw</code> subsets of equal cardinality <code>nw</code>. Each work item processes a distinct combination of replication block and point subset. More precisely, we assign to the <code>gid</code>-th work item the <code>(gid / N)</code>-th replication block for the <code>(gid % N)</code>-th point subset.</p>
<p>The kernel code from <a class="el" href="index.html#examples_rqmc">Example 3: Randomized Quasi-Monte Carlo</a> is changed to compute the index (stored in the variable <code>k</code>) of each replication that a work item is responsible for, and to partition the point set into <code>N</code> (instead of <code>get_global_size(0)</code>) subsets by invoking <a class="el" href="latticerule_8h.html#a8811331e452bbda86dc98ebff7b91096" title="Attach a new stream to a point set object in already allocated memory [device]. ">clqmcLatticeRuleCreateOverStream()</a>: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (uint kw = 0; kw &lt; rw; kw++) {</div>
<div class="line"></div>
<div class="line">  uint k = (gid / N) * rw + kw;</div>
<div class="line">  uint j = gid % N;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="latticerule_8h.html#a8811331e452bbda86dc98ebff7b91096">clqmcLatticeRuleCreateOverStream</a>(&amp;stream, pointset,</div>
<div class="line">    N, j,</div>
<div class="line">    &amp;shifts[k * DIMENSION]);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// ... (compute the value of `sum&#39; here; this is unchanged)</span></div>
<div class="line"></div>
<div class="line">  out[k * N + j] = sum / nw;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The complete code for this example is given in <a class="el" href="DocsTutorial_2example4_8c-example.html">DocsTutorial/example4.c</a> and <a class="el" href="DocsTutorial_2example4_kernel_8cl-example.html">DocsTutorial/example4_kernel.cl</a>.</p>
<p>This example is very general because it allows the extreme cases where each work item to takes care of all randomizations at single point and where each work item takes care of a single randomization at all points, and of all intermediary cases. We recall that, usually, it is preferable to use as many points as possible to obtain an accurate estimator \(\hat\mu_{\mathrm{rqmc}}\), with a small number of randomizations (maybe 5 to 30), just enough to be able to estimate the variance of \(\hat\mu_{\mathrm{rqmc}}\).</p>
<h1><a class="anchor" id="configuration"></a>
Configuration</h1>
<h2><a class="anchor" id="environment"></a>
Environment variables</h2>
<p>For all features of the library to work properly, the <code>CLQMC_ROOT</code> environment variable must be set to point to the installation path of the clQMC package, that is, the directory under which lies the <code>include/clQMC</code> subdirectory. Means of setting an environment variable depend on the operating system used.</p>
<h1><a class="anchor" id="mem_types"></a>
Device memory types</h1>
<p>The API of each point set assumes that the point set objects are stored in a specific type of memory (the stream objects are always stored in private memory). It defaults to global memory, but can be customized by the user by changing the value of the preprocessor symbol <code>CLQMC_&lt;POINTSET&gt;_OBJ_MEM</code>, where <code>&lt;POINTSET&gt;</code> is the uppercase name of the point set, before including the device header file of the point set, to one of the following values:</p>
<ul>
<li>CLQMC_MEM_TYPE_LOCAL to use local memory;</li>
<li>CLQMC_MEM_TYPE_CONSTANT to use constant memory;</li>
<li>CLQMC_MEM_TYPE_GLOBAL to use global memory (the <b>default</b>).</li>
</ul>
<p>For example, to store lattice rule objects in <b>constant memory</b>, the device code should simply begin with: </p><div class="fragment"><div class="line"><span class="preprocessor">#define CLQMC_LATTICERULE_OBJ_MEM CLQMC_MEM_TYPE_CONSTANT</span></div>
<div class="line"><span class="preprocessor">#include &lt;clQMC/latticerule.clh&gt;</span></div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>This is not implemented yet, but should be. </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 3 2016 09:36:56 for clQMC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
